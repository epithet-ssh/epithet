package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log/slog"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"

	"github.com/epithet-ssh/epithet/pkg/broker"
)

type AgentCLI struct {
	Match []string `help:"Match patterns" short:"m"`
	CaURL string   `help:"CA URL" name:"ca-url" short:"c" required:"true"`
	Auth  string   `help:"Authentication command" short:"a" required:"true"`
}

func (a *AgentCLI) Run(logger *slog.Logger) error {
	logger.Debug("agent command received", "agent", a)

	// Get home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	// Create a unique temporary directory for this broker instance
	// Use a hash of the CA URL + match patterns to make it deterministic
	instanceID := hashString(a.CaURL + fmt.Sprintf("%v", a.Match))
	tempDir := filepath.Join(homeDir, ".epithet", "run", instanceID)

	// Clean up temp directory on exit
	defer func() {
		if err := os.RemoveAll(tempDir); err != nil {
			logger.Warn("failed to remove temp directory", "error", err, "path", tempDir)
		} else {
			logger.Debug("removed temp directory", "path", tempDir)
		}
	}()

	// Create temp directory
	if err := os.MkdirAll(tempDir, 0700); err != nil {
		return fmt.Errorf("failed to create temp directory: %w", err)
	}

	// Define paths within temp directory
	brokerSock := filepath.Join(tempDir, "broker.sock")
	agentDir := filepath.Join(tempDir, "agent")

	// Create agent directory
	if err := os.MkdirAll(agentDir, 0700); err != nil {
		return fmt.Errorf("failed to create agent directory: %w", err)
	}

	// Create broker
	b := broker.New(*logger, brokerSock, a.Auth, a.CaURL, agentDir, a.Match)

	// Set up context with cancellation on signals
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigChan
		logger.Info("received shutdown signal")
		cancel()
	}()

	// Generate SSH config file in the temp directory
	sshConfigPath := filepath.Join(tempDir, "ssh-config.conf")

	if err := a.generateSSHConfig(sshConfigPath, agentDir, brokerSock, homeDir); err != nil {
		logger.Warn("failed to generate SSH config", "error", err, "path", sshConfigPath)
		// Don't fail startup, just warn
	} else {
		// Check if ~/.ssh/config has the Include directive
		includePattern := filepath.Join(homeDir, ".epithet", "run", "*", "ssh-config.conf")
		if err := checkSSHConfigInclude(homeDir, includePattern, logger); err != nil {

			logger.Warn(fmt.Sprintf("Add 'Include %s' to ~/.ssh/config", includePattern))
		}
		logger.Debug("generated SSH config", "path", sshConfigPath)
	}

	// Start broker
	logger.Info("starting broker", "socket", brokerSock, "patterns", a.Match)
	err = b.Serve(ctx)
	if err != nil && err != context.Canceled {
		return fmt.Errorf("broker serve error: %w", err)
	}

	logger.Info("broker shutdown complete")
	return nil
}

// generateSSHConfig writes an SSH config file for epithet
func (a *AgentCLI) generateSSHConfig(path, agentDir, brokerSock, homeDir string) error {
	// Find epithet binary path
	epithetPath, err := os.Executable()
	if err != nil {
		epithetPath = "epithet" // fallback to PATH
	}

	// Build host pattern list from match patterns
	hostPattern := "*"
	if len(a.Match) > 0 {
		hostPattern = ""
		for i, pattern := range a.Match {
			if i > 0 {
				hostPattern += ","
			}
			hostPattern += pattern
		}
	}

	// Generate include path with full home directory (SSH doesn't expand ~)
	includePattern := filepath.Join(homeDir, ".epithet", "run", "*", "ssh-config.conf")

	config := fmt.Sprintf(`# Generated by epithet agent - do not edit manually
# This file is automatically created when the broker starts and deleted when it stops
# Broker socket: %s
# Agent directory: %s
#
# To use epithet, add the following to ~/.ssh/config:
#   Include %s

Match host %s exec "%s match --host '%%h' --port '%%p' --user '%%r' --jump '%%j' --hash '%%C' --broker '%s'"
    IdentityAgent %s/%%C
    PubkeyAuthentication yes
    PasswordAuthentication no
    KbdInteractiveAuthentication no
    GSSAPIAuthentication no
    PreferredAuthentications publickey
    IdentityFile /dev/null
`,
		brokerSock,
		agentDir,
		includePattern,
		hostPattern,
		epithetPath,
		brokerSock,
		agentDir,
	)

	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0700); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Write config file
	if err := os.WriteFile(path, []byte(config), 0600); err != nil {
		return fmt.Errorf("failed to write SSH config: %w", err)
	}

	return nil
}

// checkSSHConfigInclude checks if ~/.ssh/config contains the Include directive for epithet
func checkSSHConfigInclude(homeDir, includePattern string, logger *slog.Logger) error {
	sshConfigPath := filepath.Join(homeDir, ".ssh", "config")

	// Read SSH config file
	content, err := os.ReadFile(sshConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			logger.Debug("~/.ssh/config does not exist", "path", sshConfigPath)
			return fmt.Errorf("SSH config not found")
		}
		return fmt.Errorf("failed to read SSH config: %w", err)
	}

	// Check for Include directive (case-insensitive, flexible whitespace)
	lines := strings.SplitSeq(string(content), "\n")
	for line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip comments
		if strings.HasPrefix(trimmed, "#") {
			continue
		}
		// Check for Include directive (case-insensitive)
		if strings.HasPrefix(strings.ToLower(trimmed), "include ") {
			// Extract the path after "Include"
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				includePath := parts[1]
				// Expand ~ if present
				if strings.HasPrefix(includePath, "~/") {
					includePath = filepath.Join(homeDir, includePath[2:])
				}
				// Check if it matches our pattern
				if includePath == includePattern {
					logger.Debug("found epithet Include directive in ~/.ssh/config")
					return nil
				}
			}
		}
	}

	return fmt.Errorf("Include directive not found")
}

// hashString creates a short hash of a string for use in filenames
func hashString(s string) string {
	h := sha256.Sum256([]byte(s))
	return hex.EncodeToString(h[:8]) // Use first 8 bytes (16 hex chars)
}

// expandPath expands ~ to the user's home directory
func expandPath(path string) (string, error) {
	if len(path) == 0 || path[0] != '~' {
		return path, nil
	}

	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	if len(path) == 1 {
		return home, nil
	}

	return filepath.Join(home, path[1:]), nil
}
