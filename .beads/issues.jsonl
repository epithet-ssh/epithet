{"id":"epithet-1","title":"Broker authentication mechanism","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:14.581322-07:00","closed_at":"2025-10-27T16:04:14.581325-07:00"}
{"id":"epithet-10","title":"Implement token refresh on certificate expiry","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T12:00:11.742798-07:00","closed_at":"2025-10-25T12:00:11.742798-07:00","dependencies":[{"issue_id":"epithet-10","depends_on_id":"epithet-1","type":"parent-child","created_at":"2025-10-22T16:09:07.717454-07:00","created_by":"import"}]}
{"id":"epithet-11","title":"Implement error handling and retry logic for auth","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:14.503926-07:00","closed_at":"2025-10-27T16:04:14.503933-07:00","dependencies":[{"issue_id":"epithet-11","depends_on_id":"epithet-1","type":"parent-child","created_at":"2025-10-22T16:09:07.717949-07:00","created_by":"import"}]}
{"id":"epithet-12","title":"epithet match command implementation","description":"","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:28:22.033941-07:00","closed_at":"2025-10-25T15:28:22.033941-07:00"}
{"id":"epithet-13","title":"Broker → CA integration","description":"","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:51.937739-07:00","closed_at":"2025-10-27T16:04:51.937744-07:00"}
{"id":"epithet-14","title":"Broker → Agent management","description":"","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:52.022792-07:00","closed_at":"2025-10-27T16:04:52.022795-07:00"}
{"id":"epithet-15","title":"Infrastructure improvements","description":"","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:52.101259-07:00","closed_at":"2025-10-27T16:04:52.101263-07:00"}
{"id":"epithet-16","title":"Create match command structure accepting --host, --port, --user, --hash arguments","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:35:23.674384024Z","dependencies":[{"issue_id":"epithet-16","depends_on_id":"epithet-12","type":"parent-child","created_at":"2025-10-22T16:09:07.718368-07:00","created_by":"import"}]}
{"id":"epithet-17","title":"Implement communication protocol with broker (IPC/RPC)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:36:08.321394864Z","dependencies":[{"issue_id":"epithet-17","depends_on_id":"epithet-12","type":"parent-child","created_at":"2025-10-22T16:09:07.718711-07:00","created_by":"import"}]}
{"id":"epithet-18","title":"Implement 5-step certificate validation workflow","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:03:32.80585-07:00","closed_at":"2025-10-25T15:03:32.80585-07:00","dependencies":[{"issue_id":"epithet-18","depends_on_id":"epithet-12","type":"parent-child","created_at":"2025-10-22T16:09:07.719097-07:00","created_by":"import"}]}
{"id":"epithet-19","title":"Add host eligibility checking (match patterns)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:28:02.945282-07:00","closed_at":"2025-10-25T15:28:02.945282-07:00","dependencies":[{"issue_id":"epithet-19","depends_on_id":"epithet-12","type":"parent-child","created_at":"2025-10-22T16:09:07.719466-07:00","created_by":"import"}]}
{"id":"epithet-20","title":"Return success/failure to OpenSSH properly","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:36:42.750426903Z","dependencies":[{"issue_id":"epithet-20","depends_on_id":"epithet-12","type":"parent-child","created_at":"2025-10-22T16:09:07.719802-07:00","created_by":"import"}]}
{"id":"epithet-21","title":"Implement certificate request flow: auth token → CA → signed certificate","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:02.800425-07:00","closed_at":"2025-10-25T15:10:02.800425-07:00","dependencies":[{"issue_id":"epithet-21","depends_on_id":"epithet-13","type":"parent-child","created_at":"2025-10-22T16:09:07.720137-07:00","created_by":"import"}]}
{"id":"epithet-22","title":"Pass connection details (host, user, port) to CA for principal determination","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:02.875796-07:00","closed_at":"2025-10-25T15:10:02.875796-07:00","dependencies":[{"issue_id":"epithet-22","depends_on_id":"epithet-13","type":"parent-child","created_at":"2025-10-22T16:09:07.720431-07:00","created_by":"import"}]}
{"id":"epithet-23","title":"Handle CA errors and policy denials","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:37.717921-07:00","closed_at":"2025-10-27T16:04:37.717927-07:00","dependencies":[{"issue_id":"epithet-23","depends_on_id":"epithet-13","type":"parent-child","created_at":"2025-10-22T16:09:07.720708-07:00","created_by":"import"}]}
{"id":"epithet-24","title":"Store returned certificates with expiry times","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:13.727953-07:00","closed_at":"2025-10-25T15:10:13.727953-07:00","dependencies":[{"issue_id":"epithet-24","depends_on_id":"epithet-13","type":"parent-child","created_at":"2025-10-22T16:09:07.720997-07:00","created_by":"import"}]}
{"id":"epithet-25","title":"Create per-connection agent instances using pkg/agent.Agent","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:13.805836-07:00","closed_at":"2025-10-25T15:10:13.805836-07:00","dependencies":[{"issue_id":"epithet-25","depends_on_id":"epithet-14","type":"parent-child","created_at":"2025-10-22T16:09:07.721274-07:00","created_by":"import"}]}
{"id":"epithet-26","title":"Implement map connection hash (%C) → agent instance","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:23.197188-07:00","closed_at":"2025-10-25T15:10:23.197188-07:00","dependencies":[{"issue_id":"epithet-26","depends_on_id":"epithet-14","type":"parent-child","created_at":"2025-10-22T16:09:07.721543-07:00","created_by":"import"}]}
{"id":"epithet-27","title":"Implement agent socket path management at ~/.epithet/sockets/%C","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:23.276431-07:00","closed_at":"2025-10-25T15:10:23.276431-07:00","dependencies":[{"issue_id":"epithet-27","depends_on_id":"epithet-14","type":"parent-child","created_at":"2025-10-22T16:09:07.721819-07:00","created_by":"import"}]}
{"id":"epithet-28","title":"Implement certificate swapping/renewal in existing agents (via UseCredential)","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:38.620417-07:00","closed_at":"2025-10-25T15:10:38.620417-07:00","dependencies":[{"issue_id":"epithet-28","depends_on_id":"epithet-14","type":"parent-child","created_at":"2025-10-22T16:09:07.722075-07:00","created_by":"import"}]}
{"id":"epithet-29","title":"Implement agent lifecycle and cleanup","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:10:38.697488-07:00","closed_at":"2025-10-25T15:10:38.697488-07:00","dependencies":[{"issue_id":"epithet-29","depends_on_id":"epithet-14","type":"parent-child","created_at":"2025-10-22T16:09:07.722345-07:00","created_by":"import"}]}
{"id":"epithet-30","title":"Implement match pattern evaluation (which hosts epithet should handle)","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T15:42:57.317814-07:00","closed_at":"2025-10-25T15:42:57.317814-07:00","dependencies":[{"issue_id":"epithet-30","depends_on_id":"epithet-15","type":"parent-child","created_at":"2025-10-22T16:09:07.722621-07:00","created_by":"import"}]}
{"id":"epithet-31","title":"Implement proper error handling throughout broker","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:37.796476-07:00","closed_at":"2025-10-27T16:04:37.796482-07:00","dependencies":[{"issue_id":"epithet-31","depends_on_id":"epithet-15","type":"parent-child","created_at":"2025-10-22T16:09:07.722886-07:00","created_by":"import"}]}
{"id":"epithet-32","title":"Add logging and observability","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:04:37.870628-07:00","closed_at":"2025-10-27T16:04:37.870634-07:00","dependencies":[{"issue_id":"epithet-32","depends_on_id":"epithet-15","type":"parent-child","created_at":"2025-10-22T16:09:07.723201-07:00","created_by":"import"}]}
{"id":"epithet-33","title":"Implement socket cleanup on expiration","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T16:55:50.724833-07:00","closed_at":"2025-10-27T16:55:50.724838-07:00","dependencies":[{"issue_id":"epithet-33","depends_on_id":"epithet-15","type":"parent-child","created_at":"2025-10-22T16:09:07.723517-07:00","created_by":"import"}]}
{"id":"epithet-34","title":"Implement graceful shutdown","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T18:36:07.515899-07:00","dependencies":[{"issue_id":"epithet-34","depends_on_id":"epithet-15","type":"parent-child","created_at":"2025-10-22T16:09:07.723805-07:00","created_by":"import"}]}
{"id":"epithet-35","title":"Implement less strict netstring parser that tolerates whitespace for debugging","description":"The current auth plugin protocol uses the markdingo/netstring library which strictly rejects whitespace between netstrings. This makes debugging auth plugins difficult. We should implement a custom netstring parser that tolerates whitespace (spaces, tabs, \\n, \\r) between netstrings while still being strict about the netstring format itself. Location: README.md:85","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-27T15:29:47.238797-07:00","closed_at":"2025-10-27T15:29:47.2388-07:00"}
{"id":"epithet-36","title":"Replace /tmp/foooo with proper tempfile location and cleanup in broker_test.go","description":"In pkg/broker/broker_test.go:18, replace hardcoded /tmp/foooo with a proper temporary file that gets cleaned up after tests","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:17:39.883538258Z"}
{"id":"epithet-37","title":"Fill in the rest of the %C connection fields in broker.go","description":"In pkg/broker/broker.go:30, the ConnectionInfo struct needs the remaining fields from the %C hash (local hostname, remote hostname, port, username, ProxyJump)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:18:48.190311982Z"}
{"id":"epithet-38","title":"Wire up epithet match arguments to broker MatchRequest RPC","description":"Add CLI arguments to MatchCLI (--host, --port, --user, --hash) and implement RPC call to broker passing all MatchRequest fields including derived LocalHost/LocalUser","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T16:22:47.109966271Z","dependencies":[{"issue_id":"epithet-38","depends_on_id":"epithet-37","type":"discovered-from","created_at":"2025-10-22T16:09:07.724121-07:00","created_by":"import"}]}
{"id":"epithet-39","title":"Implement initial authentication in broker.Match when no token exists","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T12:00:33.253643-07:00","updated_at":"2025-10-25T12:05:49.332212-07:00","closed_at":"2025-10-25T12:05:49.332212-07:00","dependencies":[{"issue_id":"epithet-39","depends_on_id":"epithet-1","type":"blocks","created_at":"2025-10-25T12:00:33.256094-07:00","created_by":"daemon"}]}
{"id":"epithet-40","title":"Handle re-authentication when CA returns 403/Forbidden","description":"","design":"Use standard HTTP semantics for auth vs authz failures:\n\n401 from CA/policy server:\n- Means: Token is invalid, expired, or missing\n- Broker action: Clear auth.token, call auth.Run() to re-authenticate, retry cert request with new token\n- User experience: Brief pause while re-authenticating, then connection proceeds (or fails for other reason)\n\n403 from CA/policy server:\n- Means: Token is valid (user authenticated), but not authorized for this access\n- May be temporary (approval workflow pending) or permanent (user lacks permission)\n- Broker action: Keep token (still valid!), return policy server error message to user, do NOT auto-retry\n- User experience: See error message explaining why (e.g., 'Approval required from ops-team'), can manually retry after approval granted\n\nThis distinction is important because:\n- 403 might resolve later (approval granted) with same token - don't force re-auth\n- 401 won't resolve without new token - must re-auth\n- Follows standard HTTP semantics (401=authentication, 403=authorization)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T12:00:36.648331-07:00","updated_at":"2025-10-27T16:03:48.592838-07:00","closed_at":"2025-10-27T16:03:48.592844-07:00","dependencies":[{"issue_id":"epithet-40","depends_on_id":"epithet-1","type":"blocks","created_at":"2025-10-25T12:00:36.650962-07:00","created_by":"daemon"}]}
{"id":"epithet-41","title":"Pass connection details to auth command for mustache template rendering","description":"Currently auth.Run() is called with nil. We should pass MatchRequest fields (host, user, port, etc.) so auth commands can use mustache templates like {{host}} or {{user}} in their command line configuration.","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-25T12:11:30.932645-07:00","updated_at":"2025-10-25T12:11:30.932645-07:00","dependencies":[{"issue_id":"epithet-41","depends_on_id":"epithet-1","type":"blocks","created_at":"2025-10-25T12:11:30.934792-07:00","created_by":"daemon"}]}
{"id":"epithet-42","title":"Update caserver for v2: accept match data and return policy with certificate","description":"Currently CreateCertRequest only has token+publicKey. Need to add match data (RemoteHost, RemoteUser, Port, etc.) and pass to policy server. CreateCertResponse should return both certificate and policy pattern so broker can store it.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T12:16:55.355488-07:00","updated_at":"2025-10-25T12:18:32.616775-07:00","closed_at":"2025-10-25T12:18:32.616775-07:00"}
{"id":"epithet-43","title":"Add comprehensive concurrency documentation and fix race conditions","description":"Add locking invariants documentation to Broker, Agent, Auth, and CertificateStore. Remove unused Agent.lock field. Fix race condition in sshd test helper by wrapping bytes.Buffer with thread-safe safeBuffer. All code now passes race detector tests.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T15:43:03.632286-07:00","updated_at":"2025-10-25T15:43:08.355558-07:00","closed_at":"2025-10-25T15:43:08.355558-07:00"}
{"id":"epithet-44","title":"Expand policy matching beyond hostname to support per-user certificates","description":"Current limitation: Policy only matches on hostPattern, but different remote users connecting to the same host may need different certificates with different principals (e.g., deploy@server vs root@server).\n\nProblem: If user SSHs to deploy@server.example.com (gets cert with principal 'deploy'), then later SSHs to root@server.example.com, the cert store lookup finds the existing cert (matches *.example.com) but it only has 'deploy' principal, not 'root', causing SSH to fail.\n\nSolution: Expand Policy struct to match on additional connection fields beyond just hostname:\n- remoteUser (e.g., 'deploy', 'root', '*')\n- Potentially localUser, port, etc.\n\nDesign questions to resolve:\n1. Should matching be AND logic (all fields must match) or pattern-based with wildcards per field?\n2. Should lookup prefer exact matches first, then fall back to broader patterns? Or most-specific-match-wins?\n3. How do we handle wildcard patterns in multiple dimensions?\n\nThis affects:\n- pkg/policy/policy.go - Policy struct and Matches() method\n- pkg/broker/certs.go - CertificateStore.Lookup() logic\n- Policy server API - may need to return more granular policies","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-25T18:39:38.843754-07:00","updated_at":"2025-10-25T18:39:38.843754-07:00"}
{"id":"epithet-45","title":"Make broker socket path configurable to support multiple concurrent brokers","description":"Currently the broker socket path defaults to ~/.epithet/broker.sock, which prevents running multiple brokers concurrently. Need to make this configurable.\n\nUse case: User may want separate brokers for work vs personal, different CA servers, different match patterns, etc.\n\nExample setup:\n- Work broker: --broker-sock ~/.epithet/work-broker.sock --match *.work.example.com\n- Personal broker: --broker-sock ~/.epithet/personal-broker.sock --match *.personal.example.com\n\nChanges needed:\n1. epithet agent command: Already has default, keep it configurable via flag/config\n2. epithet match command: Add --broker flag to specify which broker to connect to (currently hardcoded in match.go)\n3. Update SSH config examples to show broker selection\n\nNote: Agent socket directory is already configurable via --agent-sock-dir flag ✓\n\nFiles to update:\n- cmd/epithet/match.go - Add --broker flag, use instead of hardcoded path\n- cmd/epithet/agent.go - Already has --broker-sock flag ✓\n- SSH config examples in docs\n","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T18:57:24.191353-07:00","updated_at":"2025-10-27T16:07:48.384628-07:00","closed_at":"2025-10-27T16:07:48.384634-07:00"}
{"id":"epithet-46","title":"Explore SSH Match exec behavior: can we fail just the Match or does it abort the entire SSH connection?","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-25T19:44:34.301361-07:00","updated_at":"2025-10-25T19:44:34.301361-07:00"}
{"id":"epithet-47","title":"Implement 401 retry logic in broker: clear token, re-auth, retry cert request (limit retries to prevent infinite loops)","description":"When CA returns 401 Unauthorized: 1) Clear the current token, 2) Invoke auth plugin (which may use refresh token from state or do full re-auth), 3) Retry cert request with new token. Limit retries to prevent infinite loops with buggy auth plugins (suggest max 2-3 attempts). Use immediate retries (no backoff delay) - if there's a persistent issue, user will see the error and can retry the SSH connection. If retries exhausted, fail the Match and log error to stderr per epithet-48.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T19:46:17.050687-07:00","updated_at":"2025-10-27T16:03:48.518019-07:00","closed_at":"2025-10-27T16:03:48.518026-07:00"}
{"id":"epithet-48","title":"When epithet cannot obtain certificate, fail the Match (return non-zero) and log clear error to stderr","description":"When epithet cannot obtain a certificate (auth failures, CA errors, etc), the Match exec should: 1) Log clear, user-friendly error message to stderr explaining what went wrong (verbosity matching configured log level - helpful by default, more detail with -v flags), 2) Exit with non-zero status to fail the Match, 3) Allow SSH to fall through to subsequent Match blocks or default config. This enables breakglass/fallback scenarios where users have epithet Match blocks first, followed by special-case configs (e.g., breakglass@host with specific IdentityFile). Trade-off: May leak connection attempts to fallback systems, but this is acceptable to enable legitimate escape hatches.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-25T19:51:28.702502-07:00","updated_at":"2025-10-27T16:03:48.667018-07:00","closed_at":"2025-10-27T16:03:48.667023-07:00"}
{"id":"epithet-49","title":"Handle agent creation failures: keep cert in store, fail Match with clear error about local system issue","description":"When certificate is valid but agent creation fails (socket directory permissions, disk space, etc): 1) Keep certificate in cert store (it's valid and may work on retry or for other connections), 2) Fail the Match with clear error explaining the agent creation problem (not a cert/auth issue), 3) User can fix local issue and retry. Agent creation failures are typically local system problems, not certificate/policy problems.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T20:03:10.81255-07:00","updated_at":"2025-10-27T16:04:37.643402-07:00","closed_at":"2025-10-27T16:04:37.643412-07:00"}
{"id":"epithet-50","title":"Parse SSH certificate ValidBefore field to get actual expiry time instead of hardcoding 5 minutes","description":"Currently broker.Match() and ensureAgent() hardcode 5-minute expiry with TODO comments. Need to parse the SSH certificate to extract ValidBefore timestamp and use that for expiration tracking in agentEntry and PolicyCert. The golang.org/x/crypto/ssh library provides this functionality. Certificate is the source of truth for expiry time.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-10-25T20:05:43.536749-07:00","updated_at":"2025-10-27T16:03:16.619446-07:00","closed_at":"2025-10-27T16:03:16.619452-07:00"}
{"id":"epithet-51","title":"Migrate to pkg/netstr and remove old netstring library","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T15:25:37.455291-07:00","updated_at":"2025-10-27T15:29:54.452211-07:00","closed_at":"2025-10-27T15:29:54.452214-07:00"}
{"id":"epithet-52","title":"Extract pkg/netstr into standalone library","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-27T15:59:38.496556-07:00","updated_at":"2025-10-27T15:59:38.496556-07:00"}
{"id":"epithet-53","title":"Switch auth plugin protocol to fd 3 approach","description":"Replace netstring-based protocol with simpler file descriptor approach. New protocol: stdin=state, stdout=token, fd3=new_state, stderr=errors. No encoding needed, state never touches disk, easy in all languages. Changes: update CLAUDE.md docs, remove pkg/netstr, update broker to use pipes, update examples.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-27T19:50:51.322878-07:00","updated_at":"2025-10-27T20:06:09.973441-07:00","closed_at":"2025-10-27T20:06:09.973441-07:00"}
{"id":"epithet-54","title":"Support ProxyJump by adding multiple certificates to per-connection agents","description":"","notes":"FALSE ALARM - No work needed!\n\nAfter detailed analysis, the per-connection agent design ALREADY handles ProxyJump correctly:\n\n1. Each hop in a ProxyJump chain spawns a separate SSH process on local machine\n2. Each process reads ~/.ssh/config and evaluates Match exec independently  \n3. Each process gets its own %C hash (which includes %j - the ProxyJump value)\n4. Each process uses its own IdentityAgent socket path (based on its unique %C)\n5. epithet match is called separately for each hop with the correct target host\n\nExample: ssh -J jumphost remote\n- SSH Process 1: Match exec for jumphost -\u003e agent at %C_jump with jumphost cert\n- SSH Process 2: Match exec for remote -\u003e agent at %C_remote with remote cert\n\nBoth processes authenticate independently with their respective certificates. The design is sound!\n\nThe %j field is still useful for:\n- Logging/debugging (knowing which connections use jumps)\n- Policy decisions (CA might care if connection uses ProxyJump)\n- Future optimizations\n\nBut core functionality works without any code changes.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-29T20:36:50.010906-07:00","updated_at":"2025-10-29T20:43:17.385604-07:00","closed_at":"2025-10-29T20:43:05.55326-07:00"}
{"id":"epithet-55","title":"Simplify dev policy server to only allow-all and deny-all modes","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T15:07:33.819211-07:00","updated_at":"2025-10-31T15:08:52.812267-07:00","closed_at":"2025-10-31T15:08:52.812267-07:00"}
{"id":"epithet-56","title":"Update development-tools.md to remove pattern-based mode references","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T15:11:02.462729-07:00","updated_at":"2025-10-31T15:11:49.958437-07:00","closed_at":"2025-10-31T15:11:49.958437-07:00"}
{"id":"epithet-57","title":"Add --ca-pubkey flag to dev policy server for signature verification","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T15:12:39.542406-07:00","updated_at":"2025-10-31T15:13:44.674776-07:00","closed_at":"2025-10-31T15:13:44.674776-07:00"}
{"id":"epithet-58","title":"Update --ca-pubkey to accept URL, file path, or literal key","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T15:16:03.9881-07:00","updated_at":"2025-10-31T15:18:07.932844-07:00","closed_at":"2025-10-31T15:18:07.932844-07:00"}
{"id":"epithet-59","title":"Update README.md to reflect new dev policy server changes","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-31T15:18:58.960645-07:00","updated_at":"2025-10-31T15:19:19.874349-07:00","closed_at":"2025-10-31T15:19:19.874349-07:00"}
{"id":"epithet-60","title":"Set up OpenTofu example deployment for AWS Lambda + API Gateway","description":"","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-01T12:12:28.969253-07:00","updated_at":"2025-11-01T12:12:28.969253-07:00"}
{"id":"epithet-61","title":"Add 'epithet aws ca' subcommand for Lambda deployment","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-01T12:26:16.359635-07:00","updated_at":"2025-11-01T12:26:16.359635-07:00"}
{"id":"epithet-62","title":"Replace Go policy Lambda with Python implementation","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-02T14:51:59.946139-08:00","updated_at":"2025-11-02T14:51:59.946139-08:00"}
{"id":"epithet-63","title":"Make config file template expansion more robust","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T13:40:28.675409-08:00","updated_at":"2025-11-09T13:40:28.675409-08:00"}
{"id":"epithet-64","title":"Fix Python policy Lambda dependency packaging for ARM64","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T14:43:23.569986-08:00","updated_at":"2025-11-09T14:43:23.569986-08:00"}
{"id":"epithet-7","title":"Implement auth command invocation (stdin/stdout protocol)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T22:18:39.64510665Z","dependencies":[{"issue_id":"epithet-7","depends_on_id":"epithet-1","type":"parent-child","created_at":"2025-10-22T16:09:07.72441-07:00","created_by":"import"}]}
{"id":"epithet-8","title":"Implement auth state storage (map of user identity → state blob)","description":"","design":"Auth type already implements state cycling correctly in auth.go:127-171. Task is to change broker from single 'auth *Auth' to 'auths map[string]*Auth' where key is user identity (probably LocalUser from MatchRequest). Need method like GetOrCreateAuth(userID) that returns *Auth for that user.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-22T16:09:07.715489-07:00","closed_at":"2025-10-22T22:16:49.792978424Z","dependencies":[{"issue_id":"epithet-8","depends_on_id":"epithet-1","type":"parent-child","created_at":"2025-10-22T16:09:07.724683-07:00","created_by":"import"}]}
{"id":"epithet-9","title":"Implement certificate storage (map of connection hash → certificate + expiry)","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-10-22T16:09:07.715489-07:00","updated_at":"2025-10-25T11:32:56.612656-07:00","closed_at":"2025-10-25T11:32:56.612656-07:00","dependencies":[{"issue_id":"epithet-9","depends_on_id":"epithet-1","type":"parent-child","created_at":"2025-10-22T16:09:07.724945-07:00","created_by":"import"}]}
